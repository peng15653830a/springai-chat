# AI智能聊天系统 - 开发指南

> 版本：v3.0  
> 更新时间：2025年9月  
> 基于重构后的多AI提供商响应式架构

## 🛠 开发环境要求

### 基础环境
- **JDK**: 17+
- **Maven**: 3.8+
- **Node.js**: 18+
- **npm**: 8+
- **PostgreSQL**: 14+ (生产环境)

### 推荐IDE
- **后端**: IntelliJ IDEA Ultimate / VS Code
- **前端**: VS Code / WebStorm
- **数据库**: DBeaver / pgAdmin

## 🚀 快速开始

### 1. 克隆项目
```bash
git clone <repository-url>
cd springai
```

### 2. 环境配置
```bash
# 数据库配置 (PostgreSQL)
export DB_URL="jdbc:postgresql://localhost:5432/ai_chat"
export DB_USERNAME="ai_chat_user"
export DB_PASSWORD="your_password"

# 多AI提供商配置
export OPENAI_API_KEY="sk-your-openai-key"
export KIMI_API_KEY="sk-your-kimi-key"
export DEEPSEEK_API_KEY="sk-your-deepseek-key"

# 搜索API配置
export TAVILY_API_KEY="tvly-your-tavily-key"
```

### 3. 数据库初始化
```bash
# 创建数据库
createdb ai_chat

# 执行初始化脚本
psql -d ai_chat -f src/main/resources/database/init.sql
```

### 4. 后端启动
```bash
# Maven方式
mvn clean install
mvn spring-boot:run

# 或直接运行
mvn clean package
java -jar target/ai-chat-0.0.1-SNAPSHOT.jar
```

### 5. 前端启动
```bash
cd frontend
npm install
npm run dev
```

### 6. 访问应用
- **前端应用**: http://localhost:3000
- **后端API**: http://localhost:8080
- **健康检查**: http://localhost:8080/actuator/health
- **API文档**: http://localhost:8080/swagger-ui.html

## 📁 项目架构

### 后端模块结构
```
src/main/java/com/example/
├── controller/                # 控制器层
│   ├── ChatController.java           # 流式聊天接口
│   ├── ConversationController.java   # 对话管理
│   ├── ModelController.java          # 模型管理
│   └── UserController.java           # 用户管理
├── service/                   # 业务逻辑层  
│   ├── impl/                         # 实现类
│   │   ├── AiChatServiceImpl.java           # 主协调器(152行)
│   │   ├── ConversationServiceImpl.java     # 对话服务
│   │   ├── MessageServiceImpl.java          # 消息服务
│   │   └── SearchServiceImpl.java           # 搜索服务
│   ├── provider/                     # AI提供商抽象
│   │   ├── ModelProvider.java               # 统一接口
│   │   └── impl/
│   │       ├── OpenaiModelProvider.java    # OpenAI实现
│   │       ├── Kimi2ModelProvider.java     # Kimi实现
│   │       ├── DeepSeekModelProvider.java  # DeepSeek实现
│   │       └── QwenModelProvider.java      # 通义千问实现
│   ├── factory/                      # 工厂模式组件
│   │   ├── ModelProviderFactory.java       # 提供商工厂
│   │   ├── ProviderRegistry.java           # 提供商注册表
│   │   └── ProviderSelectionStrategy.java  # 选择策略
│   └── chat/                         # 聊天组件模块
│       ├── PromptBuilder.java              # 提示词构建
│       ├── ModelSelector.java              # 模型选择器
│       └── ChatErrorHandler.java           # 错误处理器
├── entity/                    # 数据实体
├── mapper/                    # MyBatis映射器
├── dto/                      # 数据传输对象
│   ├── request/                      # 请求DTO
│   ├── response/                     # 响应DTO
│   └── common/                       # 通用DTO
├── config/                   # 配置类
│   ├── SearchProperties.java         # 搜索配置
│   ├── ModelScopeProperties.java     # ModelScope配置
│   └── ChatStreamingProperties.java  # 流式配置
└── exception/                # 异常处理
```

### 前端模块结构
```
frontend/src/
├── components/               # 可复用组件
│   ├── chat/
│   │   ├── ChatContainer.vue         # 聊天容器
│   │   ├── MessageList.vue           # 消息列表
│   │   ├── MessageInput.vue          # 输入组件
│   │   └── MarkdownRenderer.vue      # 原生Markdown渲染
│   ├── conversation/
│   │   └── ConversationList.vue      # 对话列表
│   └── model/
│       └── ModelSelector.vue         # 模型选择器
├── stores/                   # Pinia状态管理
│   ├── chat.js                       # 聊天状态
│   ├── conversation.js               # 对话状态
│   └── model.js                      # 模型状态
├── api/                      # API接口封装
├── utils/                    # 工具函数
└── assets/                   # 静态资源
```

## 📝 开发规范

### 阿里巴巴Java开发规范

#### 编码规范
```java
/**
 * 服务实现类示例 - 遵循阿里巴巴规范
 * 
 * @author xupeng
 */
@Slf4j
@Service
@RequiredArgsConstructor  // 构造器注入，不使用@Autowired
public class ExampleServiceImpl implements ExampleService {
    
    private final ExampleRepository repository;
    private final ExampleProperties properties;  // 配置属性类，不使用@Value
    
    @Override
    public Mono<ExampleDto> processAsync(Long id) {
        // 【强制】使用Objects.requireNonNull进行参数校验
        Objects.requireNonNull(id, "ID不能为null");
        
        log.info("开始处理请求，ID: {}", id);
        
        return repository.findById(id)
                .switchIfEmpty(Mono.error(new BusinessException("数据不存在")))
                .map(this::convertToDto)
                .doOnSuccess(result -> log.info("处理完成，结果: {}", result))
                .doOnError(error -> log.error("处理失败", error));
    }
    
    private ExampleDto convertToDto(Example entity) {
        // 业务逻辑处理
        return ExampleDto.builder()
                .id(entity.getId())
                .name(entity.getName())
                .build();
    }
}
```

#### 配置属性类规范
```java
/**
 * 配置属性类 - 替代@Value注入
 * 
 * @author xupeng
 */
@Data
@Component
@ConfigurationProperties(prefix = "app.example")
public class ExampleProperties {
    
    /**
     * API密钥
     */
    private String apiKey;
    
    /**
     * 超时时间（毫秒）
     */
    private int timeout = 30000;
    
    /**
     * 是否启用功能
     */
    private boolean enabled = true;
}
```

#### 响应式编程规范
```java
/**
 * 响应式编程示例
 */
@Service
@RequiredArgsConstructor
public class ReactiveExampleService {
    
    private final WebClient webClient;
    
    public Flux<String> streamData(String query) {
        return webClient.get()
                .uri("/api/stream", query)
                .retrieve()
                .bodyToFlux(String.class)
                // 错误处理
                .onErrorResume(error -> {
                    log.error("流式请求失败", error);
                    return Flux.just("ERROR: " + error.getMessage());
                })
                // 背压处理
                .onBackpressureBuffer(1000)
                // 超时处理
                .timeout(Duration.ofMinutes(2));
    }
}
```

### 前端开发规范

#### Vue 3 Composition API
```vue
<template>
  <div class="chat-container">
    <MessageList :messages="messages" />
    <MessageInput @send="handleSend" />
  </div>
</template>

<script setup>
import { ref, computed, onMounted, onUnmounted } from 'vue'
import { useChatStore } from '@/stores/chat'
import MessageList from './MessageList.vue'
import MessageInput from './MessageInput.vue'

// Props
const props = defineProps({
  conversationId: {
    type: Number,
    required: true
  }
})

// Store
const chatStore = useChatStore()

// 响应式数据
const messages = computed(() => chatStore.messages)
const isLoading = ref(false)
const sseConnection = ref(null)

// 生命周期
onMounted(() => {
  initSSEConnection()
})

onUnmounted(() => {
  closeSSEConnection()
})

// 方法
const handleSend = async (message) => {
  try {
    isLoading.value = true
    await chatStore.sendMessage(props.conversationId, message)
  } catch (error) {
    ElMessage.error('发送失败: ' + error.message)
  } finally {
    isLoading.value = false
  }
}

const initSSEConnection = () => {
  const url = `/api/chat/stream?conversationId=${props.conversationId}`
  sseConnection.value = new EventSource(url)
  
  sseConnection.value.onmessage = (event) => {
    const data = JSON.parse(event.data)
    chatStore.handleStreamMessage(data)
  }
  
  sseConnection.value.onerror = () => {
    ElMessage.error('连接断开，请重试')
  }
}

const closeSSEConnection = () => {
  if (sseConnection.value) {
    sseConnection.value.close()
    sseConnection.value = null
  }
}
</script>

<style scoped>
.chat-container {
  display: flex;
  flex-direction: column;
  height: 100vh;
}
</style>
```

#### 原生Markdown渲染实现
```vue
<!-- MarkdownRenderer.vue - 替代v-md-editor -->
<template>
  <div class="markdown-content" v-html="renderedHtml"></div>
</template>

<script setup>
import { computed } from 'vue'
import { marked } from 'marked'
import hljs from 'highlight.js'
import 'highlight.js/styles/github.css'

const props = defineProps({
  content: {
    type: String,
    default: ''
  }
})

// 配置marked
marked.setOptions({
  highlight: function(code, lang) {
    if (lang && hljs.getLanguage(lang)) {
      return hljs.highlight(code, { language: lang }).value
    }
    return hljs.highlightAuto(code).value
  },
  breaks: true,
  gfm: true,
  tables: true
})

const renderedHtml = computed(() => {
  if (!props.content) return ''
  return marked(props.content)
})
</script>

<style scoped>
.markdown-content {
  line-height: 1.6;
  color: #333;
}

/* 代码块样式 */
.markdown-content pre {
  background-color: #f6f8fa;
  border-radius: 6px;
  padding: 16px;
  overflow-x: auto;
}

.markdown-content code {
  background-color: rgba(175, 184, 193, 0.2);
  padding: 2px 4px;
  border-radius: 3px;
  font-size: 85%;
}

/* 表格样式 */
.markdown-content table {
  border-collapse: collapse;
  width: 100%;
  margin: 16px 0;
}

.markdown-content th,
.markdown-content td {
  border: 1px solid #d0d7de;
  padding: 8px 12px;
  text-align: left;
}

.markdown-content th {
  background-color: #f6f8fa;
  font-weight: 600;
}
</style>
```

## 🔧 开发工具配置

### IntelliJ IDEA配置
1. **必要插件**:
   - Lombok Plugin
   - MyBatisX
   - Vue.js Plugin
   - Database Navigator

2. **代码规范**:
   - File → Settings → Editor → Code Style → Java
   - 导入阿里巴巴Java代码规范配置

3. **数据库配置**:
   - 添加PostgreSQL数据源
   - 配置连接池参数

### VS Code配置
推荐插件:
```json
{
  "recommendations": [
    "Vue.volar",
    "Vue.vscode-typescript-vue-plugin", 
    "esbenp.prettier-vscode",
    "ms-vscode.vscode-eslint",
    "bradlc.vscode-tailwindcss",
    "ms-vscode.vscode-postgresql"
  ]
}
```

## 🐛 调试指南

### 后端调试

#### 响应式调试
```java
// 启用Reactor调试
static {
    BlockHoundIntegration.builder()
        .with(new ReactorNettyIntegration())
        .install();
}

// 调试流式处理
public Flux<String> debugStream() {
    return Flux.just("a", "b", "c")
        .doOnNext(item -> log.debug("处理项目: {}", item))
        .doOnError(error -> log.error("流处理错误", error))
        .doOnComplete(() -> log.debug("流处理完成"));
}
```

#### 日志配置
```yaml
# application-dev.yml
logging:
  level:
    com.example: DEBUG
    com.example.service.chat: TRACE
    reactor.netty: DEBUG
    org.springframework.web.reactive: DEBUG
```

#### 数据库调试
```yaml
# 显示SQL语句
mybatis:
  configuration:
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl

# PostgreSQL连接调试
spring:
  datasource:
    url: jdbc:postgresql://localhost:5432/ai_chat?loggerLevel=DEBUG
```

### 前端调试

#### SSE连接调试
```javascript
// stores/chat.js
export const useChatStore = defineStore('chat', {
  state: () => ({
    sseConnection: null,
    connectionStatus: 'disconnected'
  }),
  
  actions: {
    initSSE(conversationId) {
      const url = `/api/chat/stream?conversationId=${conversationId}`
      console.log('🔌 正在建立SSE连接:', url)
      
      this.sseConnection = new EventSource(url)
      
      this.sseConnection.onopen = () => {
        console.log('✅ SSE连接已建立')
        this.connectionStatus = 'connected'
      }
      
      this.sseConnection.onmessage = (event) => {
        console.log('📥 收到SSE消息:', event.data)
        this.handleMessage(JSON.parse(event.data))
      }
      
      this.sseConnection.onerror = (error) => {
        console.error('❌ SSE连接错误:', error)
        this.connectionStatus = 'error'
      }
    }
  }
})
```

#### Vue DevTools配置
```javascript
// main.js
const app = createApp(App)

if (process.env.NODE_ENV === 'development') {
  app.config.devtools = true
  app.config.debug = true
}
```

## 🧪 测试指南

### 后端测试

#### 单元测试示例
```java
@ExtendWith(MockitoExtension.class)
class AiChatServiceImplTest {
    
    @Mock
    private ModelSelector modelSelector;
    
    @Mock
    private PromptBuilder promptBuilder;
    
    @InjectMocks
    private AiChatServiceImpl aiChatService;
    
    @Test
    void shouldHandleStreamChat() {
        // Given
        when(modelSelector.selectModel(anyString(), anyString(), anyLong()))
            .thenReturn(new ModelSelection("openai", "gpt-3.5-turbo"));
        
        when(promptBuilder.buildPrompt(anyLong(), anyString(), anyBoolean()))
            .thenReturn(Mono.just("test prompt"));
        
        // When
        Flux<SseEventResponse> result = aiChatService.streamChatWithModel(
            1L, "test message", false, false, 1L, "openai", "gpt-3.5-turbo");
        
        // Then
        StepVerifier.create(result)
            .expectNextCount(1)
            .verifyComplete();
    }
}
```

#### 集成测试
```java
@SpringBootTest
@TestPropertySource(properties = {
    "spring.datasource.url=jdbc:h2:mem:testdb",
    "spring.ai.openai.api-key=test-key"
})
class ChatControllerIntegrationTest {
    
    @Autowired
    private WebTestClient webTestClient;
    
    @Test
    void shouldStreamChat() {
        webTestClient.get()
            .uri("/api/chat/stream?conversationId=1&message=hello")
            .accept(MediaType.TEXT_EVENT_STREAM)
            .exchange()
            .expectStatus().isOk()
            .expectHeader().contentType(MediaType.TEXT_EVENT_STREAM)
            .expectBodyList(String.class)
            .hasSize(greaterThan(0));
    }
}
```

### 前端测试

#### Vue组件测试
```javascript
// tests/components/MessageList.test.js
import { mount } from '@vue/test-utils'
import MessageList from '@/components/chat/MessageList.vue'

describe('MessageList', () => {
  it('should render messages correctly', () => {
    const messages = [
      { id: 1, role: 'user', content: 'Hello' },
      { id: 2, role: 'assistant', content: 'Hi there!' }
    ]
    
    const wrapper = mount(MessageList, {
      props: { messages }
    })
    
    expect(wrapper.findAll('.message')).toHaveLength(2)
    expect(wrapper.text()).toContain('Hello')
    expect(wrapper.text()).toContain('Hi there!')
  })
})
```

#### E2E测试
```javascript
// tests/e2e/chat.spec.js
import { test, expect } from '@playwright/test'

test('should send and receive messages', async ({ page }) => {
  await page.goto('/')
  
  // 发送消息
  await page.fill('[data-testid="message-input"]', 'Hello AI')
  await page.click('[data-testid="send-button"]')
  
  // 验证消息显示
  await expect(page.locator('.message-user')).toContainText('Hello AI')
  
  // 等待AI回复
  await expect(page.locator('.message-assistant')).toBeVisible()
})
```

## 📦 构建和部署

### 本地构建
```bash
# 完整构建流程
./build.sh

# 或手动构建
mvn clean package -DskipTests
cd frontend && npm run build
cp -r frontend/dist/* src/main/resources/static/
mvn spring-boot:repackage
```

### Docker部署
```dockerfile
# Dockerfile
FROM openjdk:17-jdk-alpine

VOLUME /tmp

# 安装PostgreSQL客户端
RUN apk add --no-cache postgresql-client

COPY target/ai-chat-*.jar app.jar

# 健康检查
HEALTHCHECK --interval=30s --timeout=10s --start-period=30s --retries=3 \
  CMD curl -f http://localhost:8080/actuator/health || exit 1

ENTRYPOINT ["java", "-jar", "/app.jar"]
```

```yaml
# docker-compose.yml
version: '3.8'
services:
  postgres:
    image: postgres:14-alpine
    environment:
      POSTGRES_DB: ai_chat
      POSTGRES_USER: ai_chat_user
      POSTGRES_PASSWORD: password
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
      
  ai-chat:
    build: .
    ports:
      - "8080:8080"
    environment:
      - DB_URL=jdbc:postgresql://postgres:5432/ai_chat
      - DB_USERNAME=ai_chat_user
      - DB_PASSWORD=password
      - OPENAI_API_KEY=${OPENAI_API_KEY}
      - TAVILY_API_KEY=${TAVILY_API_KEY}
    depends_on:
      - postgres

volumes:
  postgres_data:
```

## 🔍 性能优化

### 响应式性能优化
```java
@Configuration
public class WebFluxConfig implements WebFluxConfigurer {
    
    @Bean
    public WebClient webClient() {
        ConnectionProvider provider = ConnectionProvider.builder("ai-providers")
            .maxConnections(100)
            .maxIdleTime(Duration.ofSeconds(30))
            .maxLifeTime(Duration.ofMinutes(5))
            .pendingAcquireTimeout(Duration.ofSeconds(10))
            .evictInBackground(Duration.ofSeconds(10))
            .build();
            
        return WebClient.builder()
            .clientConnector(new ReactorClientHttpConnector(
                HttpClient.create(provider)))
            .build();
    }
}
```

### PostgreSQL优化
```sql
-- 索引优化
CREATE INDEX CONCURRENTLY idx_messages_conversation_created 
ON messages(conversation_id, created_at);

CREATE INDEX CONCURRENTLY idx_messages_content_gin 
ON messages USING gin(to_tsvector('english', content));

-- 连接池配置
spring.datasource.hikari.maximum-pool-size=20
spring.datasource.hikari.minimum-idle=5
spring.datasource.hikari.connection-timeout=30000
spring.datasource.hikari.idle-timeout=600000
spring.datasource.hikari.max-lifetime=1800000
```

### 前端性能优化
```javascript
// 虚拟滚动实现
import { VirtualList } from '@tanstack/vue-virtual'

// 防抖优化
import { debounce } from 'lodash-es'

const searchMessages = debounce(async (query) => {
  // 搜索逻辑
}, 300)

// 懒加载组件
const ModelSelector = defineAsyncComponent(() => 
  import('@/components/model/ModelSelector.vue')
)
```

## 🛡 安全最佳实践

### 后端安全
```java
@Configuration
@EnableWebSecurity
public class SecurityConfig {
    
    @Bean
    public SecurityFilterChain filterChain(ServerHttpSecurity http) {
        return http
            .csrf(csrf -> csrf.disable())
            .cors(cors -> cors.configurationSource(corsConfigurationSource()))
            .authorizeHttpRequests(auth -> auth
                .pathMatchers("/api/public/**").permitAll()
                .anyExchange().authenticated()
            )
            .build();
    }
}

// 输入验证
@RestController
@Validated
public class ChatController {
    
    @PostMapping("/send")
    public Mono<ApiResponse> sendMessage(
            @Valid @RequestBody ChatRequest request) {
        // 请求已通过@Valid验证
        return chatService.processMessage(request);
    }
}
```

### 前端安全
```javascript
// XSS防护
const sanitizeHtml = (html) => {
  return DOMPurify.sanitize(html, {
    ALLOWED_TAGS: ['p', 'br', 'strong', 'em', 'code', 'pre'],
    ALLOWED_ATTR: []
  })
}

// API密钥安全
// ❌ 错误 - 不要在前端存储API密钥
const apiKey = 'sk-xxx'

// ✅ 正确 - 通过后端代理
const callAI = (message) => {
  return axios.post('/api/chat', { message })
}
```

## 📚 扩展开发

### 添加新的AI提供商
```java
@Service
public class NewAIProvider implements ModelProvider {
    
    private final WebClient webClient;
    private final NewAIProperties properties;
    
    @Override
    public Flux<SseEventResponse> streamChat(ChatRequest request) {
        return webClient.post()
            .uri(properties.getApiUrl())
            .headers(this::setAuthHeaders)
            .bodyValue(buildRequestBody(request))
            .retrieve()
            .bodyToFlux(String.class)
            .map(this::parseResponse);
    }
    
    @Override
    public String getProviderName() {
        return "newai";
    }
}

// 配置属性
@Data
@Component  
@ConfigurationProperties(prefix = "newai")
public class NewAIProperties {
    private String apiKey;
    private String apiUrl;
    private String defaultModel;
}
```

### 自定义错误处理
```java
@Service
public class CustomChatErrorHandler implements ChatErrorHandler {
    
    @Override
    public Flux<SseEventResponse> handleChatError(Throwable error) {
        ErrorType errorType = classifyError(error);
        
        return switch (errorType) {
            case RATE_LIMIT_ERROR -> handleRateLimitError(error);
            case API_KEY_ERROR -> handleApiKeyError(error);
            case QUOTA_EXCEEDED -> handleQuotaError(error);
            default -> handleGenericError(error);
        };
    }
}
```

## ❓ 故障排查

### 常见问题解决

#### 1. PostgreSQL连接问题
```bash
# 检查PostgreSQL服务状态
systemctl status postgresql

# 验证连接
psql -h localhost -U ai_chat_user -d ai_chat -c "SELECT version();"

# 检查连接配置
grep -r "jdbc:postgresql" src/main/resources/
```

#### 2. AI API调用失败
```java
// 添加详细日志
@Slf4j
@Component
public class AIApiHealthCheck {
    
    @EventListener
    @Async
    public void handleProviderError(ProviderErrorEvent event) {
        log.error("AI提供商 {} 调用失败: {}", 
            event.getProviderName(), event.getError().getMessage());
            
        // 发送告警通知
        alertService.sendAlert("AI提供商异常", event);
    }
}
```

#### 3. SSE连接异常
```javascript
// 前端连接监控
const monitorSSEConnection = (eventSource) => {
  let reconnectCount = 0
  const maxReconnects = 5
  
  const reconnect = () => {
    if (reconnectCount < maxReconnects) {
      setTimeout(() => {
        reconnectCount++
        console.log(`尝试重连 (${reconnectCount}/${maxReconnects})`)
        initSSEConnection()
      }, 1000 * reconnectCount)
    } else {
      ElMessage.error('连接失败，请刷新页面重试')
    }
  }
  
  eventSource.onerror = (error) => {
    console.error('SSE连接错误:', error)
    reconnect()
  }
}
```

#### 4. 性能问题诊断
```bash
# JVM性能监控
jconsole
# 或者
java -XX:+FlightRecorder -XX:StartFlightRecording=duration=60s,filename=app.jfr -jar app.jar

# PostgreSQL性能分析
EXPLAIN ANALYZE SELECT * FROM messages WHERE conversation_id = 1;

# 前端性能分析
npm run build -- --analyze
```

---

**开发支持**: 如遇到开发问题，请查阅相关技术文档或提交Issue  
**代码贡献**: 欢迎提交PR，请确保遵循开发规范和测试覆盖率要求  
**技术讨论**: 可在项目Discussion区域进行技术交流