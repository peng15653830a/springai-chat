# 后端架构评估报告（OOP 视角 & Spring AI 1.0.0 实践）

本文对 backend 模块从面向对象设计与 Spring AI 1.0.0 特性使用两方面进行全面评估，重点关注：分层职责、可维护性、复杂度控制、对现有框架能力的复用度，以及可落地的优化建议与改造路线图。

评估所依据的代码范围：
- 入口与配置：`springai/SpringaiApplication.java`、`config/*`、`application.yml`
- 控制器与服务：`controller/*`、`service/*`、`service/impl/*`
- AI 集成与管理：`manager/ChatClientManager.java`、`integration/ai/*`、`strategy/*`
- 基础设施：`memory/DatabaseChatMemory.java`、`mapper/*`、`entity/*`
- 工具调用：`tool/WebSearchTool.java`


## 总览结论

- 分层清晰度总体良好：Controller → Service → Mapper 的职责划分基本到位，异常处理、配置、工具调用等也有独立模块，便于维护与扩展。
- Spring AI 1.0.0 的核心能力已被采用：`ChatClient` Builder、`@Tool` 注解工具、`MessageChatMemoryAdvisor` + 自定义 `ChatMemory` 历史注入、流式输出与工具上下文 `ToolContext` 等均在使用。
- 仍存在“重复/绕路”的实现与命名不一致问题，造成复杂度上升：
  - ChatModel Bean 命名与 `ChatClientManager` 的查找策略不一致，导致“按 provider 精确取模”经常失败并回退到默认模型（功能隐患）。
  - 同时存在“配置阶段创建的 ChatClient Bean”和“运行时由 `ChatClientManager` 构建的 ChatClient”，前者未被使用且未装配默认工具/记忆，属于冗余实现。
  - Prompt 与 Memory 双重注入历史/系统提示，造成上下文重复；同时 `deepThinking` 等参数未真正透传到模型调用，存在“参数有 UI、后端未生效”的设计错位。
  - SSE 事件发布器中 ThreadLocal 方案与 `toolContext`/会话级 Sink 并存，复杂度偏高且实际用途有限，可简化为纯基于会话 ID 的发布。
  - 搜索调用使用 Apache HttpClient（阻塞），与 WebFlux/reactor 生态不一致；在工具函数中阻塞调用会影响吞吐。

整体建议：统一“一个真·ChatClient 构建路径”（`ChatClientManager`），一次性装配默认 System、Tool、Memory；Prompt 只承载“当前用户问题 + 可选补充上下文”，历史交给 Memory 注入，系统提示交给 `defaultSystem`；修正 provider→ChatModel 的映射；移除不必要的 ThreadLocal 与冗余 Bean；按需将 Search 改造为 WebClient。


## 设计亮点（优点）

- 职责分离与可测性
  - Controller 仅做参数绑定与流式返回；Service 聚合业务流程；Mapper 专注持久化，对象命名规范统一，便于 IDE/静态检查与测试（如 `ChatControllerTest` 等）。
  - 全局异常处理 `GlobalExceptionHandler` 对常见错误分类明确，返回统一 `ApiResponse`，降低接口不一致风险。
- Spring AI 特性落地
  - `ChatClientManager` 通过 Builder 装配 `defaultSystem`、`defaultTools(@Tool)`、`MessageChatMemoryAdvisor`，符合 Spring AI 1.0 推荐路径。
  - `WebSearchTool` 使用 `@Tool` 与 `ToolContext` 获取上下文（会话/消息 ID），并通过 SSE 发布搜索进度/结果，用户体验友好。
  - 自定义 `DatabaseChatMemory` 实现历史持久化，配合 `MessageChatMemoryAdvisor` 将历史注入模型，具备可控性和可替换性。
- 流式交互与可观测
  - 基于 `Flux` 合并“搜索事件流 + 模型输出流”，清晰表达“准备→执行→完成”的阶段性流程，日志粒度合理。
  - `MessageToolResultService` 将工具调用轨迹落库，便于回溯与审计。


## 主要问题与风险点（需优先处理）

1) ChatModel Bean 命名与查找策略不一致（功能正确性）
- 现状：`ChatClientManager#getChatClient(provider)` 通过 `provider.toLowerCase() + "ChatModel"` 查找 Bean；而配置类创建的 Bean 名称为 `customOpenAiChatModel`、`deepSeekChatModel`、`greatWallChatModel`，与推导名不匹配（如 DeepSeek → 期望 `deepseekChatModel`，实际是 `deepSeekChatModel`）。
- 影响：按 provider 精确获取模型失败，回退到“第一个模型”，造成“选择了某 provider/模型但实际未生效”的隐性问题。
- 建议（任选其一，优先 A）：
  - A. 在 `ChatClientManager` 里维护 provider→ChatModel 的显式映射（初始化时根据 `MultiModelProperties#providers` 构建，大小写不敏感），不再依赖 Bean 名推导。
  - B. 统一各 `@Bean` 方法命名为 `{provider}ChatModel`（完全小写），与推导规则一致；OpenAI 去掉 `custom` 前缀。

2) ChatClient 的构建路径重复且不一致（复杂度/一致性）
- 现状：配置类同时定义了 ChatModel 与 ChatClient Bean，但业务侧又通过 `ChatClientManager` 动态基于 ChatModel 构建 ChatClient，并注入默认工具/记忆；配置阶段生成的 ChatClient Bean 未被使用，且也未装配默认 Advisor/Tool。
- 影响：
  - 概念重复、易混淆；
  - 若有人误注入到配置生成的 ChatClient，将丢失 Tool/Memory，行为不一致。
- 建议：移除配置类中 ChatClient Bean 定义，仅保留 ChatModel Bean；所有 ChatClient 实例统一由 `ChatClientManager` 负责。

3) 历史与系统提示“双重注入”（上下文重复）
- 现状：
  - `ChatClientManager.defaultSystem(...)` 已注入系统提示；同时 `DefaultPromptBuilder.buildPromptFromMessages(...)` 又拼接了一段系统提示文本到“用户消息”中；
  - `MessageChatMemoryAdvisor` 会注入历史对话；同时 PromptBuilder 也将历史拼到“用户消息”中（"历史对话：..."）。
- 影响：模型收到的“系统/历史”上下文双份甚至冲突，增加 token 和困惑度。
- 建议：
  - 系统提示只保留一处：推荐保留 `ChatClientManager.defaultSystem`；PromptBuilder 不再重复系统提示。
  - 历史由 Memory 注入；PromptBuilder 不再拼接“历史对话：xxx”，仅构造“用户当下问题 + 可选补充上下文（如搜索总结）”。

4) `deepThinking`/模型选项未透传（体验/一致性）
- 现状：`StreamChatRequest.deepThinking` 仅打日志，未映射到模型选项；`GreatWallChatOptions` 有 `enableThinking` 但未按请求切换；其他 OpenAI 兼容模型的 options 也未根据请求调整。
- 建议：
  - 在 `AiChatServiceImpl` 中，基于 `ModelSelector` 结果为本次调用设置 `ChatOptions`（温度、maxTokens、enableThinking 等），通过 `prompt().options(...)` 或模型默认 options 的拷贝修改来传递；
  - 对不支持 thinking 的模型，忽略该选项并告知前端能力差异。

5) SSE 事件发布器中过度使用 ThreadLocal（复杂度/维护性）
- 现状：`SseEventPublisherImpl` 维护 `currentConversationId`/`currentSearchResults` 的 ThreadLocal，同时也提供了基于 `conversationId` 的显式发布方法，工具调用侧已拿到 `ToolContext` 可直接传会话 ID。
- 建议：
  - 移除 ThreadLocal，仅保留 `conversationId → Sinks.Many` 的发布与事件存储；
  - 统一工具侧调用 `publishXxx(conversationId, ...)` 的重载（当前已经这么用），降低并发/泄露风险。

6) 搜索调用阻塞与栈不一致（性能/一致性）
- 现状：`SearchServiceImpl` 使用 Apache HttpClient（阻塞）；而整体链路使用 WebFlux。
- 建议：改为 Spring `WebClient` 并在 `@Tool` 函数内以非阻塞方式收集结果（或在 ChatClient 的工具调用线程池上安全阻塞，至少与全局线程池隔离）。

7) 配置与安全
- `application.yml` 中 PostgreSQL 默认用户名/密码为本地默认开发值，建议改为严格依赖环境变量，避免误用；
- `MultiModelProperties#isProviderAvailable` 通过硬编码 `activeProfiles={"default"}` 判断开发环境，应改为注入 `Environment` 检查 `spring.profiles.active`。

8) 领域模型与持久化的一致性
- `Message#searchResults` 已不再持久化使用（工具结果改为 `message_tool_results`），建议移除该字段，避免误用。
- Mapper 混用 XML 与注解风格，建议统一（团队可约定全部 XML 或全部注解）。


## Spring AI 1.0.0 特性使用评估

- 已使用（评价“合适”）
  - `ChatClient` Builder + `defaultSystem` + `defaultTools(@Tool)`：集中式装配、可复用；
  - `MessageChatMemoryAdvisor` + 自定义 `ChatMemory`：实现历史注入与持久化；
  - `@Tool` + `ToolContext`：在工具里拿到 `conversationId`/`messageId`，并将工具结果与消息关联入库；
  - `.stream().chatResponse()`：流式输出与 SSE 整合合理。

- 可进一步利用的能力
  - 结构化输出与对象映射：复杂工具结果（如搜索）可改为返回结构化 POJO，由模型感知 JSON 字段（比长文本拼接更鲁棒）；
  - Prompt 模板：对提示语的变体与可配置化，可考虑使用 `PromptTemplate`（但在简化上下文之后再引入，避免过度工程）；
  - 观察与重试：结合 Spring Retry/Resilience4j 或 Spring AI 的 advisor（若符合）为调用增加统一重试与熔断策略。


## 建议的简化方案（降低复杂度）

1) “一个 ChatClient，单一构建路径”
- 保留：`ChatClientManager` 负责按 provider 返回 ChatClient，装配统一的 `defaultSystem`、`defaultTools`、`MessageChatMemoryAdvisor`。
- 移除：所有配置类中“ChatClient Bean”定义，仅保留“ChatModel Bean”。
- 修正：provider→ChatModel 的映射（见上文“问题 1”建议）。

2) Prompt 只做“当前任务”
- PromptBuilder 仅返回“用户当下问题 + 可选轻量上下文（如搜索摘要）”；
- 系统提示固定在 `defaultSystem`；历史仅由 Memory 注入；避免 token 冗余与上下文冲突。

3) 工具结果结构化
- `WebSearchTool#searchWeb` 可返回 `List<SearchResult>` 或包装对象，由 ChatClient 以结构化工具返回供模型吸收；
- SSE 侧依然筛选可展示的来源链接，前端体验不变。

4) 移除 ThreadLocal
- `SseEventPublisherImpl` 去除 ThreadLocal，仅基于 `conversationId` 路由到 `Sinks.Many`；
- WebSearchTool 中统一使用 `publishXxx(conversationId, ...)` 重载。

5) 统一 HTTP Client
- 搜索改用 `WebClient`，与 WebFlux 栈一致；为 Tavily 增加超时/重试策略与错误分类，重用全局 `ObjectMapper`。

6) 配置清理
- `application.yml` 中数据库默认凭据改为空值或全部走环境变量默认值，避免误启动连到本机固定库；
- `MultiModelProperties#isProviderAvailable` 注入 `Environment` 替代硬编码 profile。


## 渐进式改造路线图（建议优先级）

- P0（立即）
  - 修正 provider→ChatModel 映射，避免选错模型（功能正确性）。
  - 统一 ChatClient 构建路径（移除配置阶段的 ChatClient Bean）。
  - 去掉 Prompt 中的系统提示与历史拼接，保留 `defaultSystem` 与 Memory 注入。

- P1（两迭代内）
  - 将 `deepThinking`/温度/最大 token 等按请求透传到 `ChatOptions`；
  - 搜索改为 `WebClient`；
  - 移除 `SseEventPublisher` ThreadLocal；
  - 移除 `Message#searchResults` 字段并清理相关死代码；
  - 统一 Mapper 风格（XML or 注解）。

- P2（后续增强）
  - 工具返回结构化对象 + PromptTemplate（在不增加复杂度的前提下）；
  - 观察/重试策略统一治理；
  - 将用户模型偏好改为持久化（替代内存 Map）。


## 附：关键文件与问题定位指引

- ChatClient 管理：`manager/ChatClientManager.java`
  - Bean 名推导与实际 `@Bean` 名不一致，导致回退逻辑频繁触发。
- 配置里的 ChatClient Bean（建议移除）：
  - `config/OpenAiCompatibleConfig.java`、`config/DeepSeekConfig.java`、`config/GreatWallConfig.java`
- Prompt/历史重复：`strategy/prompt/DefaultPromptBuilder.java` + `ChatClientManager.defaultSystem(...)` + `MessageChatMemoryAdvisor`
- Thinking 未透传：`dto/request/StreamChatRequest.java`、`service/impl/AiChatServiceImpl.java`、`integration/ai/greatwall/GreatWallChatOptions.java`
- SSE ThreadLocal（建议去除）：`service/impl/SseEventPublisherImpl.java`
- 搜索阻塞调用：`service/impl/SearchServiceImpl.java`
- 配置硬编码/安全：`config/MultiModelProperties.java`、`resources/application.yml`
- 已废弃字段：`entity/Message.java#searchResults`


## 结语

当前后端整体架构是健康且可维护的，但存在几处“重复与不一致”的实现导致复杂度上升和潜在功能错配。按照本报告的 P0/P1 建议执行小步重构，可显著提升一致性、可读性与运行确定性，并更充分地发挥 Spring AI 1.0.0 的框架价值。

